package routing.control;

import core.Message;
import core.Settings;
import core.control.ControlMessage;
import core.control.DirectiveCode;
import routing.MessageRouter;

/**
 * This class implements a controller able to collect network metric messages
 * and generate directives with that information. The generated directives are
 * applied by the routers.
 * 
 */
public class Controller {
	/** namespace of the controller settings ({@value}) */
	public static final String CONTROL_NS = "control";
	/** package where to look for controller engines */
	private static final String CONTROL_PACKAGE = "routing.control";

	/** engine -setting id ({@value}) in the controller name space */
	public static final String ENGINE_S = "engine";
	/** engine -setting id ({@value}) in the controller name space */ 
	public static final String NROF_CONTROLLERS_S = "nrofControllers";	
	/** Default setting value for the engine of a controller */
	public static final String AGGREGATION_ENGINE = "AggregationEngine";
	/** Engine to be used to generate directives. */
    protected DirectiveEngine directiveEngine;
    /** If there is just one controller in the simulation it is set to true. 
     * True is the default value.*/
    private boolean isACentralizedController = true;

	/**
	 * Constructor that initializes the engine used to generate directives, 
	 * based on the settings configuration and on the router configuration. 
	 * It sets if the controller is a centralized one (case where there is
	 * just one controller).
	 * It initializes the controlProperties with an empty map mean to be 
	 * fed by the routers themselves.  
	 * @param settings Settings of the name space: GROUP_NS and GROUP_NS+i
	 */
	public Controller(MessageRouter router) {
		// TODO Auto-generated constructor stub
		Settings s = new Settings(CONTROL_NS);
		int nrofControllers;
		this.setDirectiveEngine(s);
		
		if(s.contains(NROF_CONTROLLERS_S)){
			nrofControllers = s.getInt(NROF_CONTROLLERS_S);
			s.ensurePositiveValue(nrofControllers, NROF_CONTROLLERS_S);
			this.isACentralizedController = (nrofControllers == 1) ? true : false;
		}
		
	}
		
	/**
	 * Method that adds an entry to the engine controlProperties map. 
	 * This entry corresponds to a router property to be used by the engine to 
	 * generate a directive. For instance, 
	 * an SprayAndWaitRouter contains the nrof_copies of the message. 
	 * @param code the code of the router property.
	 * @param initialValue The value of this property
	 */
    public void putControlProperty(DirectiveCode code, Double initialValue) {
    	this.directiveEngine.putControlProperty(code, initialValue);
    }

	/**
	 * Method that adds all the entries in the map parameter, to the engine 
	 * controlProperties map.  
	 * @param properties the properties of the router to be added to the 
	 * properties engine map.
	 */
    public void putControlProperties(ControlPropertyMap properties) {
    	this.directiveEngine.putControlProperties(properties);
    }
	
	/**
	 * Method that builds the engine used to generate directives, 
	 * based on the settings configuration of the specified engine. 
	 * @param settings Settings of the name space: controller
	 */
    protected void setDirectiveEngine(Settings s) {
		String engineNameSpace = (s.contains(ENGINE_S)) ? s.getSetting(ENGINE_S) : AGGREGATION_ENGINE;
		Settings engineSettings = new Settings(engineNameSpace);
		String directiveEngine_str = CONTROL_PACKAGE + "." + engineNameSpace;
		
		this.directiveEngine= (DirectiveEngine)engineSettings.createIntializedObject(
				directiveEngine_str);
    }   
    
    
    /**
     * Getter of the attribute isACentralizedController.
     * @return True if there is just one controller in the scenario. False if 
     * there are more than one.
     */
    public boolean isACentralizedController() {
    	return this.isACentralizedController;
    }
    
    /**
     * Method that injects a metric into the directiveEngine to be considered 
     * when generating the next directive. 
     * @param message the message containing metrics.
     */
    public void addMetric(ControlMessage message) {
    	this.directiveEngine.addMetric(message);
    }
        	
    /**
     * Method that injects a metric into the directiveEngine to be considered 
     * when generating the next directive. 
     * @param message the message containing a directive.
     */    
    public void addDirective(ControlMessage message) {
    	this.directiveEngine.addDirective(message);
    }
    
	/**
	 * Method called by the event generated by the eventGenerator when it 
	 * comes the time to generate a new directive. This method delegates to the 
	 * directiveEngine the production of a new directive. The directiveEngine 
	 * produces a new directive in the case the current network situation, 
	 * mesured by the metrics and directives being injected since the last 
	 * directive was generated, demands a new network configuration.   
	 * @param message Message to be filled with the generated directive's fields.
	 * If no directive is generated by calling this method, the message is not
	 * changed. 
	 * @return True if the message has been updated with the fields of a new 
	 * generated directive. False otherwise.
	 *  
	 */
	public boolean fillMessageWithDirective(Message message) {
		return this.directiveEngine.generateDirective((ControlMessage)message);
    }

}
